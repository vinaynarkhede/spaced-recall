# Linux Network Namespaces - High Quality Flashcards
# Format: ID	Question	Answer (use <br> for line breaks in answer)
# Following AGENT_README_v2.md first-principles guidelines

NET001	WHY do network interfaces exist in Linux? What problem do they solve?	<b>PROBLEM:</b> A computer needs multiple "doors" to send/receive traffic - one for local communication, others for external networks, VPNs, containers, etc.<br><br><b>SOLUTION:</b> Network interfaces are abstracted "doors" for traffic.<br><br><b>TWO TYPES:</b><br>• Physical interfaces (eth0, wlan0) - connected to hardware<br>• Virtual interfaces (lo, veth, docker0) - created by software<br><br><b>NAMING CONVENTION:</b><br>• eth0, eth1 = Ethernet (wired)<br>• wlan0 = Wireless LAN (WiFi)<br>• lo = Loopback (always 127.0.0.1)<br><br><b>KEY INSIGHT:</b> Interfaces aren't just hardware - they're an ABSTRACTION that lets Linux treat virtual network paths the same as physical ones. This is what makes containers possible.

NET002	WHAT is the loopback interface (lo)? Why does EVERY system have one and what problem does it solve?	<b>DEFINITION:</b> A virtual interface that always points back to the same computer. IP: 127.0.0.1 (localhost).<br><br><b>THE PROBLEM IT SOLVES:</b><br>Without loopback: Programs need special IPC code to talk locally<br>With loopback: Programs use SAME networking code for local and remote<br><br><b>WHY EVERY SYSTEM HAS ONE:</b><br>1. Testing servers without a network<br>2. Inter-process communication (database connections)<br>3. Services binding to localhost for security<br>4. Development (localhost:3000)<br><br><b>KEY DIFFERENCES FROM eth0:</b><br>• lo: Traffic NEVER leaves the computer<br>• eth0: Traffic goes to physical network<br>• lo: Always 127.0.0.1/8<br>• eth0: Assigned IP (e.g., 192.168.1.100)<br><br><b>COMMON USE:</b> mysql -h 127.0.0.1 connects via loopback even though MySQL is on same machine.

NET003	WHAT are the three private IP ranges (RFC 1918)? WHY do they exist and when to use each?	<b>THE THREE RANGES:</b><br><br>1. <b>10.0.0.0/8</b> (Class A)<br>• Size: 16,777,216 addresses<br>• Use: Large enterprises, data centers<br>• Example: 10.0.1.50<br><br>2. <b>172.16.0.0/12</b> (Class B)<br>• Size: 1,048,576 addresses<br>• Range: 172.16.x.x to 172.31.x.x<br>• Use: Docker, WSL2, VPNs<br>• Example: 172.17.0.2 (Docker container)<br><br>3. <b>192.168.0.0/16</b> (Class C)<br>• Size: 65,536 addresses<br>• Use: Home networks, small offices<br>• Example: 192.168.1.1 (your router)<br><br><b>WHY THEY EXIST (RFC 1918, 1996):</b><br>• Free to use (no registration)<br>• Internet routers won't route them (security)<br>• Reusable (every home uses 192.168.x.x)<br>• NAT translates to public IP when needed<br><br><b>KEY INSIGHT:</b> These ranges provide isolation AND allow infinite reuse. Without them, we'd have run out of IPv4 addresses decades ago.

NET004	HOW does CIDR notation work? Explain /24, /16, /8 and how to calculate available hosts.	<b>CIDR</b> = Classless Inter-Domain Routing<br><br><b>THE FORMAT:</b> IP/prefix (e.g., 192.168.1.100/24)<br>• The /number = how many bits are the NETWORK portion<br>• Remaining bits = HOST portion<br><br><b>CALCULATION:</b><br>• Total bits in IPv4 = 32<br>• Host bits = 32 - prefix<br>• Available hosts = 2^(host bits) - 2<br><br><b>COMMON PREFIXES:</b><br>/24 = 256 addresses (254 usable) - Network: 24 bits, Host: 8 bits<br>/16 = 65,536 addresses<br>/8 = 16,777,216 addresses<br>/32 = 1 address (single host, used for Tailscale)<br><br><b>HOW TO READ 192.168.1.100/24:</b><br>• Network: 192.168.1 (first 24 bits)<br>• Host: 100 (last 8 bits)<br>• Range: 192.168.1.0 to 192.168.1.255

NET005	WHAT is a routing table and HOW does the kernel use it to decide where to send packets?	<b>DEFINITION:</b> A set of rules telling the kernel "to reach destination X, send via interface Y through gateway Z."<br><br><b>THE DECISION PROCESS:</b><br>1. Kernel receives outgoing packet for IP X<br>2. Scans routing table top-to-bottom<br>3. Finds FIRST matching rule (most specific wins)<br>4. Sends packet via that interface/gateway<br><br><b>EXAMPLE TABLE:</b><br>192.168.1.0/24 → wlan0 (local network)<br>10.0.0.0/8 → eth0 (VPN network)<br>0.0.0.0/0 → gateway 192.168.1.1 (default route)<br><br><b>SPECIAL ENTRIES:</b><br>• 0.0.0.0/0 = Default route (catch-all)<br>• Gateway 0.0.0.0 = "directly connected"<br>• Gateway with IP = "send to this router first"<br><br><b>KEY INSIGHT:</b> More specific routes (/24) take precedence over less specific (/0). This is how VPNs work - they add more specific routes.

NET006	WHAT is a gateway? WHY is it needed and what happens when you try to reach an IP outside your network?	<b>DEFINITION:</b> The "exit door" from your local network to reach other networks.<br><br><b>WHY IT'S NEEDED:</b><br>Your computer knows IPs on its local network (e.g., 192.168.1.x)<br>But it has NO IDEA how to reach 8.8.8.8 (Google DNS)<br>Gateway = "I don't know how to reach this, ask this router"<br><br><b>HOW IT WORKS:</b><br>1. Packet to 142.250.185.46 (google.com)<br>2. Routing table: not in local network<br>3. Falls to default route: gateway 192.168.1.1<br>4. Packet sent to router<br>5. Router knows how to forward to internet<br><br><b>IN ROUTING TABLE:</b><br>• Gateway = 0.0.0.0 means "directly connected"<br>• Gateway = 192.168.1.1 means "send to this IP first"<br><br><b>KEY INSIGHT:</b> Your home router is your default gateway. Corporate networks may have multiple gateways for different subnets.

NET007	WHAT is iptables? Name its THREE main tables and when each is used.	<b>DEFINITION:</b> Linux's built-in firewall system. A security guard that inspects EVERY packet and decides: allow, block, or modify.<br><br><b>THE THREE MAIN TABLES:</b><br><br>1. <b>FILTER TABLE</b> (default)<br>• Purpose: Accept/drop packets<br>• Chains: INPUT, OUTPUT, FORWARD<br>• Example: Block all SSH (port 22)<br><br>2. <b>NAT TABLE</b><br>• Purpose: Modify source/destination addresses<br>• Chains: PREROUTING, POSTROUTING, OUTPUT<br>• Example: Port forwarding (80 → 8080)<br><br>3. <b>MANGLE TABLE</b><br>• Purpose: Modify packet headers (TTL, TOS)<br>• Use: QoS, traffic shaping<br><br><b>WHY NAMESPACES MATTER:</b><br>Each network namespace has its OWN iptables rules! Container A can block port 22 while Container B allows it.<br><br><b>KEY INSIGHT:</b> Docker uses iptables NAT table extensively for port mapping (-p 8080:80).

NET008	WHAT is a network bridge (like docker0)? HOW is it different from a router?	<b>DEFINITION:</b> A virtual switch that connects multiple network segments, allowing devices to communicate as if on the same network.<br><br><b>BRIDGE VS ROUTER:</b><br>• Bridge (Layer 2): Connects devices on SAME network using MAC addresses<br>• Router (Layer 3): Connects DIFFERENT networks using IP addresses<br><br><b>HOW docker0 BRIDGE WORKS:</b><br>1. Docker creates virtual bridge "docker0" (default 172.17.0.1)<br>2. Each container gets a veth pair<br>3. One end in container (eth0), other end on docker0<br>4. Containers can talk via bridge<br>5. Bridge connects to host's real interface for external access<br><br><b>VISUAL:</b><br>Container1 (172.17.0.2) ──┐<br>                          ├── docker0 ── eth0 ── internet<br>Container2 (172.17.0.3) ──┘<br><br><b>KEY INSIGHT:</b> docker0 is why containers can reach each other using 172.17.0.x IPs and why you can reach containers from the host.

NET009	WHY do ports exist? What's the difference between well-known, registered, and dynamic ports?	<b>THE PROBLEM PORTS SOLVE:</b><br>One IP address, but many applications need to receive traffic.<br>Without ports: 192.168.1.100 can only run ONE service.<br>With ports: Same IP serves web (80), SSH (22), database (3306) simultaneously.<br><br><b>PORT RANGES:</b><br><br><b>WELL-KNOWN (0-1023):</b><br>• Require root/admin to bind<br>• 80=HTTP, 443=HTTPS, 22=SSH, 3306=MySQL<br><br><b>REGISTERED (1024-49151):</b><br>• Common applications<br>• 3000=Dev servers, 5432=PostgreSQL, 8080=Alt HTTP<br><br><b>DYNAMIC/EPHEMERAL (49152-65535):</b><br>• Temporary, auto-assigned<br>• Client-side source ports<br><br><b>PORT BINDING:</b><br>When a program "binds" to port 80, it CLAIMS exclusive use. Another program gets: "Address already in use"<br><br><b>WHY NAMESPACES ARE POWERFUL:</b><br>Default namespace: App A on port 80<br>Container "blue": App B on port 80 ✓ No conflict!

NET010	WHAT do interface flags mean? Explain UP, LOWER_UP, LOOPBACK, BROADCAST, MULTICAST.	<b>WHEN YOU RUN "ip addr":</b><br>eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;<br><br><b>EACH FLAG MEANING:</b><br><br><b>UP:</b> Interface is administratively ENABLED (turned on, not necessarily connected)<br><br><b>LOWER_UP:</b> Physical layer is connected (cable plugged in, WiFi connected)<br><br><b>LOOPBACK:</b> This is the loopback interface (only "lo" has this)<br><br><b>BROADCAST:</b> Can send to all devices on network (e.g., 192.168.1.255)<br><br><b>MULTICAST:</b> Can send/receive multicast packets (streaming, service discovery)<br><br><b>QUICK DIAGNOSIS:</b><br>• &lt;UP,LOWER_UP&gt; ✓ Working<br>• &lt;UP&gt; only ⚠️ Cable unplugged!<br>• Neither ❌ Disabled

NET011	WHY do Linux network namespaces exist? What specific problem do they solve for containers?	<b>THE PROBLEM:</b><br>On a single Linux system:<br>• Only ONE process can bind to port 80<br>• All processes share the same routing table<br>• All processes share the same firewall rules<br>• All processes see the same network interfaces<br><br>IMPACT: Can't run multiple isolated network services.<br><br><b>THE SOLUTION - NETWORK NAMESPACES:</b><br>Give each container/app its OWN:<br>1. Network interfaces (its own eth0, lo)<br>2. IP addresses<br>3. Routing tables<br>4. Firewall rules (iptables)<br>5. Port bindings<br><br>RESULT: Each container is like a separate computer, network-wise.<br><br><b>REAL-WORLD EXAMPLE:</b><br>• Container A: nginx on port 80<br>• Container B: apache on port 80<br>• Container C: python http.server on port 80<br>All running simultaneously, no conflict!<br><br><b>KEY INSIGHT:</b> This is THE foundational technology for container networking.

NET012	WHAT gets isolated in a network namespace? List ALL 5 components.	<b>COMPLETE ISOLATION LIST:</b><br><br>1. <b>NETWORK INTERFACES</b><br>• Each namespace has its own eth0, lo<br>• New namespace starts with ONLY loopback<br><br>2. <b>IP ADDRESSES</b><br>• Each namespace has its own IP assignments<br>• 10.0.0.1 in namespace A ≠ 10.0.0.1 in namespace B<br><br>3. <b>ROUTING TABLES</b><br>• Each namespace has its own routing rules<br><br>4. <b>FIREWALL RULES (iptables)</b><br>• Each namespace has independent iptables<br><br>5. <b>PORT BINDINGS</b><br>• Each namespace has its own port space<br><br><b>WHAT IS NOT ISOLATED:</b><br>• Filesystem (separate isolation mechanism)<br>• PIDs (separate isolation mechanism)<br>• Users (separate isolation mechanism)<br><br><b>KEY INSIGHT:</b> A new namespace is EMPTY - only loopback exists. YOU must configure interfaces, IPs, routes. This is what Docker does automatically.

NET013	HOW do you create, manage, and execute commands in a network namespace? Provide exact commands.	<b>CREATING NAMESPACES:</b><br>sudo ip netns add blue<br>ip netns list<br>sudo ip netns delete blue<br><br><b>EXECUTING COMMANDS INSIDE:</b><br>sudo ip netns exec blue ip addr<br>sudo ip netns exec blue bash<br><br><b>CONFIGURING A NEW NAMESPACE:</b><br># Create namespace<br>sudo ip netns add blue<br><br># Loopback is DOWN by default, bring it up<br>sudo ip netns exec blue ip link set lo up<br><br># Verify<br>sudo ip netns exec blue ip addr<br><br><b>COMMON DEBUGGING:</b><br># See interfaces<br>sudo ip netns exec blue ip addr<br># See routes<br>sudo ip netns exec blue ip route<br># Check ports<br>sudo ip netns exec blue ss -tulpn<br><br><b>KEY INSIGHT:</b> ip netns exec is like "SSH into" the namespace. Everything after it runs in that isolated network environment.

NET014	WHAT is a veth pair? WHY is it needed to connect namespaces?	<b>DEFINITION:</b> A virtual Ethernet pair - like a virtual cable with two ends. Anything sent into one end comes out the other.<br><br><b>WHY IT'S NEEDED:</b><br>Namespaces are ISOLATED by default. There's no path between them. veth pairs CREATE that path - they're the "cable" connecting isolated networks.<br><br><b>HOW IT WORKS:</b><br>1. Create pair: veth-blue &lt;===&gt; veth-red<br>2. Put veth-blue in namespace "blue"<br>3. Put veth-red in namespace "red"<br>4. Assign IPs to each end<br>5. Now they can communicate!<br><br><b>COMMANDS:</b><br>sudo ip link add veth-blue type veth peer name veth-red<br>sudo ip link set veth-blue netns blue<br>sudo ip link set veth-red netns red<br>sudo ip netns exec blue ip addr add 10.0.0.1/24 dev veth-blue<br>sudo ip netns exec blue ip link set veth-blue up<br><br><b>DOCKER USAGE:</b> Every container has a veth pair - one end inside container, other end on docker0 bridge.

NET015	WHAT happens when Docker runs a container? Describe the EXACT network setup steps.	<b>DOCKER NETWORK SETUP (step by step):</b><br><br>1. <b>CREATE NETWORK NAMESPACE</b><br>Docker creates new namespace for container (EMPTY, only loopback)<br><br>2. <b>CREATE VETH PAIR</b><br>One end named eth0 (goes inside container), other end goes on bridge<br><br>3. <b>MOVE INTERFACE TO CONTAINER</b><br>eth0 moved into container's namespace<br><br>4. <b>ATTACH TO BRIDGE</b><br>Other veth end attached to docker0 bridge<br><br>5. <b>ASSIGN IP ADDRESS</b><br>Docker picks IP from bridge subnet (172.17.0.x)<br><br>6. <b>CONFIGURE ROUTING</b><br>Default route via docker0 gateway (172.17.0.1)<br><br><b>RESULT:</b><br>Container eth0 (172.17.0.2) ─── veth ─── docker0 (172.17.0.1) ─── host eth0 ─── internet<br><br><b>WHY -p 8080:80 WORKS:</b><br>Docker adds iptables NAT rule: "Traffic to host:8080 → forward to 172.17.0.2:80"

NET016	WHY can't a container bind to a Tailscale IP? Explain the namespace isolation issue step-by-step.	<b>THE SCENARIO:</b><br>Host has Tailscale: 100.66.197.8<br>You try: docker run -p 100.66.197.8:8080:80 nginx<br>Error: "Cannot assign requested address"<br><br><b>STEP-BY-STEP WHY IT FAILS:</b><br><br>1. Tailscale creates tailscale0 interface in HOST namespace<br>Host sees: lo, eth0, tailscale0 ✓<br><br>2. Container starts in its OWN namespace<br>Container sees: lo, eth0 (veth to docker0)<br>Container does NOT see: tailscale0 ❌<br><br>3. Docker tries to bind to 100.66.197.8:8080<br>Kernel checks: "Do I have interface with this IP?"<br>In container's namespace: NO such interface<br>Error: Cannot assign requested address<br><br><b>THE RULE:</b> You can ONLY bind to IP addresses that exist in YOUR namespace.<br><br><b>SOLUTIONS:</b><br>1. --network host (container uses host's namespace)<br>2. Bind to 0.0.0.0 (Docker forwards)<br>3. Install Tailscale inside container

NET017	WHY can't Docker Desktop (on Windows/WSL2) access Windows Tailscale? Explain the kernel boundary issue.	<b>THE ARCHITECTURE:</b><br>Windows Host (Windows Kernel)<br>├── Tailscale Interface: 100.66.197.8 ← HERE<br>└── WSL2 (Hyper-V VM - Linux Kernel)<br>    ├── Ubuntu Namespace (no tailscale0)<br>    └── docker-desktop Namespace (Docker Engine, also no tailscale0)<br><br><b>WHY IT'S IMPOSSIBLE:</b><br>• Network namespaces are a LINUX KERNEL feature<br>• Windows uses completely different networking<br>• WSL2 is a REAL Linux VM (separate kernel!)<br>• You CANNOT "join" namespaces across kernels<br><br><b>THE KEY INSIGHT:</b><br>This isn't just namespace isolation - it's KERNEL BOUNDARY. Different operating systems, different network stacks, no direct bridging.<br><br><b>SOLUTION:</b><br>Install Tailscale INSIDE WSL2:<br>curl -fsSL https://tailscale.com/install.sh | sh<br>sudo tailscale up<br><br>Now Tailscale and Docker share the same Linux kernel.

NET018	HOW does a network call flow from application to physical wire? Trace ALL layers.	<b>COMPLETE FLOW (browser to 192.168.1.50:8080):</b><br><br>1. <b>APPLICATION LAYER</b>: Browser wants to connect<br><br>2. <b>SOCKET LAYER</b>: Creates socket, specifies TCP + destination<br><br>3. <b>TRANSPORT LAYER</b>: Adds source port (54321) + dest port (8080)<br><br>4. <b>NETWORK LAYER</b>: Adds source IP + destination IP<br><br>5. <b>ROUTING DECISION</b>: Kernel checks routing table, picks interface<br><br>6. <b>INTERFACE SELECTION</b>: Packet goes to wlan0<br><br>7. <b>DATA LINK LAYER</b>: Adds source MAC + destination MAC<br><br>8. <b>PHYSICAL LAYER</b>: WiFi card converts to radio signals, transmits<br><br><b>FOR LOOPBACK (127.0.0.1):</b><br>Steps 1-5 same, but:<br>• Step 5: Route says "use lo interface"<br>• Steps 7-8: SKIPPED (no physical transmission)<br>• Packet loops back at kernel level

NET019	COMPARE: How would you explain namespaces vs containers vs VMs to someone new?	<b>ISOLATION SPECTRUM (least to most):</b><br><br><b>PROCESSES (no isolation):</b><br>• Share everything: network, filesystem, memory<br>• One crash can affect others<br><br><b>NETWORK NAMESPACES (network isolation only):</b><br>• Isolated: Network stack<br>• Shared: Filesystem, CPU, memory<br><br><b>CONTAINERS (namespace bundle):</b><br>• Isolated: Network + PID + filesystem + users<br>• Shared: Kernel, CPU resources (cgroups limit)<br><br><b>VIRTUAL MACHINES (full isolation):</b><br>• Isolated: EVERYTHING including kernel<br>• Own OS, own kernel, own memory<br><br><b>KEY INSIGHT:</b><br>• Namespace = one isolation dimension<br>• Container = multiple namespaces bundled<br>• VM = complete isolation but heavier<br><br><b>RULE OF THUMB:</b><br>• Same kernel? → Namespaces possible<br>• Different kernel? → Need VM<br>• Docker on Windows? → Actually runs in Linux VM (WSL2)

NET020	WHAT is the principle "isolation by default, connection by choice"? How does it apply to container networking?	<b>THE PRINCIPLE:</b><br>Start with COMPLETE isolation (security).<br>Connect ONLY what needs to communicate (functionality).<br>Control EXACTLY how they communicate (firewall, routing).<br><br><b>APPLICATION TO CONTAINERS:</b><br><br><b>DEFAULT STATE:</b><br>• Container starts in isolated namespace<br>• No connection to host network<br>• No connection to other containers<br>• Can't be reached from outside<br><br><b>YOU CHOOSE TO CONNECT:</b><br>• -p 8080:80 → Expose specific port<br>• --network mynet → Join Docker network<br>• --link db → Connect to container<br>• --network host → Full access (least secure)<br><br><b>SECURITY BENEFIT:</b><br>• Container compromise doesn't expose other services<br>• Explicit connections = auditable attack surface<br><br><b>KEY INSIGHT:</b> This is why you CAN'T reach a container unless you explicitly expose it. It's a feature, not a bug.<br><br><b>ANTI-PATTERN:</b> --network host "for convenience" removes all isolation benefits.
